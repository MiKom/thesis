\chapter{Isosurface extraction with Marching Cubes}

This chapter will present a method of isosurface extraction that is later used
in the programming project. First, basic definitions will be established and
rationale for generating graphics with volumetric data will be discussed.
Next, brief history and high level overview of Marching Cubes will be presented.
Technical details will follow with description of implementation on highly
parallel GPGPU systems with OpenCL.

\section{Definitions}

\begin{defn}[Density function]
\label{def:density function}
Scalar function
$\mathbb{R}^3\rightarrow\mathbb{R}$ or $\mathbb{R}^2\rightarrow\mathbb{R}$
that defines value of some magnitude in a continuous space. An example of such
function in 3D space is temperature defined in each point in the space. Height
on a flat map on the other hand is a density function in 2D space.
\end{defn}

\begin{defn}[Isosurface]
Surface in three-dimensional space that consists of points that have certain
value of \emph{density function}.
\end{defn}

\begin{defn}[Isovalue]
Certain value of density function which will be considered the surface. Points
in domain which density function value is below this value are considered to
lie below the surface and points which density function value is above this
value are considered to lie above the surface. Points which density function
value equals isovalue are considered to lie exactly on the isosurface.
\end{defn}

\section{Rationale for isosurface rendering}

There are many applications which yield data as a density function. Some of them
are listed below:
\begin{description}
	\item[CT\footnotemark scan.]\footnotetext{Computer Tomography}
		Result of such scan is a discrete lattice of points with certain
		values on vertices
	\item[Weather data]
		Weather data, especially coming from weather models consists of
		scalar values of various parameters (temperature, humidity, etc.)
		on earth's surface
	\item[Arbitrary mathematical function]
		It's often desirable to visualise mathematical function with
		multiple parameters on 2D and 3D plots. For example for
		educational purposes.
	\item[Procedural models]
		Surfaces expressed by density function may be a source of
		visually interesting models that could be hard to model by hand.
\end{description}

Interactive presentation of such data may be very helpful while working with
these applications. Ability to rotate, zoom and scale such surfaces may be
beneficial to understanding the data since human sight apparatus is naturally
well equipped to process 3D objects and images.

\section{Marching Cubes algorithm overview}
\subsection{History \parencite{mchist}}
Marching Cubes algorithm was invented in 1984 by William E. Lorensen and Harvey
E. Cline. While being employed by General Electric they attended a seminar by
GE's Medical Systems Business Group employee Carl Crawford. Mr Crawford
described capabilities of the upcoming rendering engine called \emph{Graphicon},
that rendered using polygons. He also challenged seminar attendees to find
interesting usages for the device. Within a day Lorenson and Cline devised an
algorithm that read volumetric medical data (essentially a density function) and
produced triangle mesh representing isosurface.

General Electric submitted a patent application for the algorithm on
June~5, 1985, which was granted on December~1, 1987 \parencite{mcpatent}.

Partly due to existence of this patent, another algorithm for isosurface
extraction called \emph{Marching Tetrahedra} was invented to give graphics
community method that is not encumbered by patents. \emph{Marching Tetrahedra}
also solves some ambiguities that are present in \emph{Marching Cubes}.

Patent on \emph{Marching Cubes} algorithm expired in 2005.

\subsection{Algorithm description \parencite{Lorensen:1987:MCH:37402.37422}}
\label{sec:mcdesc}

Marching cubes algorithm divides space on which it operates into a discrete
lattice of cubes. For each cube, density function value is retrieved for each
vertex of the cube. Density function may be calculated from the position of the
vertex on the fly if it's defined as a mathematical function, or it may be
extracted from some external volumetric data source (e.g. result of CT scan).

Next, for each edge of the cube it's determine whether value at given vertex is
larger or smaller than requested isovalue. If the value on the vertex is smaller
than the threshold isovalue, vertex is below the surface. Otherwise it's above
it.

Being above or below the surface will be called the \emph{sign} of the vertex.
If vertices on the ends of given cube's edge are of different signes, than it's
certain that the surface crosses the edge.

For each cube, there are $2^8=256$ possible combinations of sings of the
vertices. Combination of the cube is called an \emph{index} of this cube.

When the index of the cube is known, pre-generated LUTs\footnote{Look-Up Tables}
are consulted to determine how many polygons and in what configuration should be
emitted for this cube.

Original version of Marching Cubes algorithm divides all 256 possible
combinations of vertices into 15 cases. These cases are presented in
\autoref{fig:mccases}. Remaining combinations are derivatives of these cases
(symmetries, rotations, and complimentary cases).

Process is repeated for all cubes in the lattice emitted polygons are the output
of the algorithm.

\begin{figure}
  \centerline{
    \begin{tikzpicture}[z={(-0.58cm,-0.28cm)}, scale=1.5]
    \input{chapters/marchingcubes/cases.tex}
    \end{tikzpicture}
  }
  \caption{
    All cases in traditional Marching cubes algorithm. Vertices with density
    function above threshold value have black circles on them. Symmetries,
    rotations, and complementary cases (with exception of cases 0 and 255) were
    omitted for brevity.
  }
  \label{fig:mccases}
\end{figure}

\subsubsection{Cube indexing}

Operation on a single cube begins with evaluating density function on each
vertex of the cube.

Index of the vertex is calculated through operation described below
\autoref{fig:mcnumbering}.

\begin{figure}
  \centerline{
   \input{chapters/marchingcubes/numbering.tex}
  }
  \caption{
    Numbering of vertices and edges in Marching Cubes. Cube index is
    derived by concatenation of bits \texttt{index = v8|v7|v6|v5|v4|v3|v2|v1}
    where each \texttt{vi} is logical result (0 or 1) of operation of comparing
    density function value at \emph{i}-th vertex with threshold value
    (\texttt{value(i) > threshold}).
  }
  \label{fig:mcnumbering}
\end{figure}

\subsubsection{Emitting polygons}

When index of the cube is known, LUT is consulted that maps index to list of
edges on which vertex in given cube must be emitted.

\begin{lstlisting}[caption={Index to edge list LUT. Notice that for indices 0
and 255 no geometry is emitted}]
unsigned char mcTriangleTable[256][16] = {
        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
        {0, 8, 3, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
        ...
        {0, 3, 8, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
        {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
};
\end{lstlisting}

For each edge on the list vertex is emitted between its two ends in place
proportional to the linear interpolation of density function at the vertices.

Each three vertices form a polygon. In the listing above, value 255 marks an end
of the list for given index.

Next, each polygon is saved in a list for later usage, or directly fed to
rendering device.

\section{Implementation on GPU with OpenCL}
\label{sec:mcgpu}
Following implementation is based on example code from NVIDIA CUDA SDK
example\footnote{\url{http://docs.nvidia.com/cuda/cuda-samples/index.html\#marching-cubes-isosurfaces}}.

As described in \autoref{sec:mcdesc} each cube is processed by the algorithm
independently. This possibly makes this algorithm a good candidate for massive
parallelization offered by GPGPUs. There are however some obstacles to overcome.

First, LUTs used by the algorithm are obviously too big to fit into registers.
Reading them from global memory would also be problematic, because they are
accessed in a random manner, depending on cube index. Tables could be copied
to local memory for faster access, but the cost of copying for each block could
be substantial.

Another problem is storage of the output. It is not known beforehand how many
polygons will be emitted by each cube. With sequential implementation it isn't a
problem because data generated by each cube may be just appended to single
result array. With many cubes being process at the same time, this approach
will not work.

\subsection{Stages in GPU implementation}
Kernel execution is divided into the following stages:
\todo{insert image with stages diagram}

All operations are performed on cube lattice flattened to 1D array.
\subsubsection{Voxel classification}

In this stage, all voxels are classified as to whether they will produce any
geometry or not, and how many vertices is given voxel going to produce.

Results are written to two arrays \texttt{voxelOccupied} which contains 1
if given voxel produces any geometry and 0 otherwise, and
\texttt{voxelVerts} that holds number of vertices produced by this voxel:
\todo{Find out about having single listing with some dialect}
\begin{lstlisting}[language=opencl, numbers=left]
__kernel
void classifyVoxel(
	__global uint *voxelVerts,
	__global uint *voxelOccupied,
	uint4 gridSize,
	float4 voxelSize,
	float isoValue,
	uint numVoxels,
	__read_only image2d_t numVertsTex)
{
	uint i = get_global_id(0);
	float4 cubeValues[8];
	/* Here, values on each vertex of the voxel are inserted into cubeValues array */

	int cubeIndex = getCubeIndex(cubeValues, isoValue);
	uint numVerts = read_imageui(numVertsTex, tableSampler, (int2)(cubeIndex, 0)).x;
	if (i < numVoxels) {
		voxelVerts[i] = numVerts;
		voxelOccupied[i] = (numVerts > 0);
	}
}
\end{lstlisting}
Note that additional lookup table (\texttt{numVertsTex}) that maps cube index to
number of vertices it produces is used. This LUT is accessed as a texture.

Index of the cube is calculated as described in \autoref{fig:mcnumbering}:

\begin{lstlisting}
int getCubeIndex(float4 *cubeValues, float isoValue)
{
	int cubeIndex;
	cubeIndex =  (cubeValues[0].w < isoValue);
	cubeIndex += (cubeValues[1].w < isoValue) << 1;
	cubeIndex += (cubeValues[2].w < isoValue) << 2;
	/*...*/
	cubeIndex += (cubeValues[7].w < isoValue) << 7;
	return cubeIndex;
}
\end{lstlisting}

\subsubsection{Compacting}
To overcome problem highlighted in \autoref{sec:mcgpu} a special compacting
operation is performed on arrays from previous step. First, a prefix-sum array
is computed in parallel on the GPU on \texttt{voxelOccupied} array resulting
int \texttt{voxelOccupiedScan} array.

\begin{defn}[Prefix-sum operation \parencite{BlellochTR90}]
operation that takes binary associative operator $\oplus$ with identity $I$ and
an array of $n$ elements $[a_0,a_1,\ldots,a_{n-1}]$ and returns the array
$[I,a_0,(a_0\oplus a_1),\ldots,(a_0\oplus a_1 \oplus \ldots \oplus a_{n-2})]$
\end{defn}

By reading the last elements of \texttt{voxelOccupied} and
\texttt{voxelOccupiedScan} and adding them, the number of voxels that will
produce geometry can be obtained.

\todo{replace figure \ref{fig:mccompact} with proper graphics}

\begin{figure}
	\begin{center}
		\includegraphics[width=\textwidth]{chapters/marchingcubes/compact.jpg}
	\end{center}
	\caption{Scan operation on \texttt{voxelVerts} array gives indexes to
		final result array for every active voxel.
	}
	\label{fig:mccompact}
\end{figure}

\subsection{Parallel prefix sum operation}
